#!/bin/busybox sh
. /opt/common.shell

LOG "Starting installation of corvix GNU/Linux"


#######
# Boot Options
###

# Defaults
export break=
export quiet=n
export readonly=y
export rootmnt=/rootfs
export debug=
export cryptopts=${CRYPTOPTS}
export ROOTDELAY=
export panic=

export ARCH=i686
export BOOTMODE=install
export DEV=eth0
export IP=dhcp
export GATE=
export DNS=
export CFGFILE=default.cfg
export TARGET=
export SOURCE=

# Parse boot options
LOG "Parse boot options"
for x in $(cat /proc/cmdline); do
   case $x in
   mode=*)
      BOOTMODE=${x#mode=}
      ;;
   dev=*)
      DEV=${x#dev=}
      ;;
   ip=*)
      IP=${x#ip=}
      ;;
   dns=*)
      DNS=${x#dns=}
      ;;
   config=*)
      CFGFILE=${x#config=}
      ;;
   target=*)
      TARGET=${x#target=}
      ;;
   source=*)
      SOURCE=${x#source=}
      ;;
   arch=*)
      ARCH=${x#arch=}
      ;;
   break=*)
      break=${x#break=}
      ;;
   break)
      break=premount
      ;;
   esac
done

depmod -a
maybe_break top  # debians stuff

# dhclient
LOG "DHCP to:$none $DEV"
ipconfig -c dhcp -d $DEV

# derived defaults
LOG "Configuration file: $none$CFGFILE"
export firsthd=$TARGET
export srcdisk=$SOURCE


# searching harddisks
search_disks() {
    for hd in /sys/block/hd* /sys/block/sd*; do
        [ -d $hd ] || continue
        [ "0" == "$(cat $hd/removable)" ] && echo "/dev/$(basename $hd)" >> /hdlist
        [ "1" == "$(cat $hd/removable)" ] && echo "/dev/$(basename $hd)" >> /cdlist
    done    
    [ -z "$firsthd" -o "$firstcd"="auto" ] && firsthd=$(head -1 /hdlist)
    [ -z "$srcdisk" -o "$srcdisk"="cdrom" ] && srcdisk=$(head -1 /cdlist)
}


prepare_setting() {
    #TODO: use xdialog?

    (echo $CFGFILE | awk '/^http:/{exit}{exit 1}') && 
    (rm /default.cfg; wget -O /default.cfg $CFGFILE || DIE "Cannot load configuration file from $CFGFILE")
    . /default.cfg
    search_disks
    
cat << eof

####### installation settings #######

config file      = $CFGFILE
target harddisk  = $firsthd
bootstrap source = $SOURCE
ip address       = $IP
gateway          = $GATE
dns              = $DNS
architecture     = $ARCH
init scripts     = $INITSCR

#####################################

eof

    WARN "WARNING: All hardisk space in $firsthd will be used"
    read -p "Proceed? (Y/n) " OK
    [ "$OK" == "n" ] && DIE "Installation canceled"

}


prepare_parti() {
    WARN "WARNING: deleting all partitions in $firsthd..."
    NPAR=$(fdisk $firsthd -l|awk '/^\/dev\//{print}'|wc -l)
    mesg "DELETING: $NPAR partitions"
    parti=1
    while [ $parti -lt $NPAR ]; do
       LOG+ "Deleting partition $NPAR on $firsthd"
       echo -ne "d\n1\nw\n\n" | fdisk $firsthd 
       [ $NPAR -ne 0 ] && echo -ne "d\nw\n\n" | fdisk $firsthd 
       parti=$[ $parti + 1 ]
    done

    LOG "CREATING: partition"
    echo -ne "n\np\n1\n\n\na\n1\nw\n\n" | fdisk $firsthd 
	 ln -s /proc/mounts /etc/mtab
	 LOG "FORMATING: ${firsthd}1"
	 _ mkfs.ext3 ${firsthd}1 || DIE "!!!! Formating failed !!!!"
	 mkdir /rootfs 
	 mount -t ext3 ${firsthd}1 /rootfs || DIE "!!!! Mounting filesystem failed !!!!"
}


# bootstrap
take_from_cd() {
   LOG "Exploding bootstrap image from cdrom: $srcdisk:/images/bootstrap-${ARCH}.tgz"
   mkdir /mnt
   mount -t iso9660 $srcdisk /mnt
   cd /rootfs
   [ -f /mnt/images/bootstrap-${ARCH}.tgz ] || DIE "Cannot find bootstrap image for ${ARCH}"
   _ tar xzvf /mnt/images/bootstrap-${ARCH}.tgz
}


take_from_http() {
	LOG "Downloading bootstrap image from $SOURCE"
	wget -O /rootfs/bootstrap.tgz $SOURCE && (cd /rootfs; tar xzvf bootstrap.tgz)
	rm bootstrap.tgz
}


take_from_cmd() {
	SOURCE=$(echo $SOURCE | awk '{sub(/^~/,"");print}')
	LOG "Running installation command: $SOURCE"
	echo "#!/bin/sh" > /runcmd
	cd /
	$SOURCE
}


take_load_run() {
	SOURCE=$(echo $SOURCE | awk '{sub(/^\^/,"");print}')
	cd /
	LOG "Loading installation script from: $SOURCE"
	wget -O runcmd $SOURCE
	chmod +x runcmd
	./runcmd
	# the script must return 255 to stop further processes
	[ $! = 255 ] && exit
}


make_bootstrap() {
	case $SOURCE in 
	cdrom)
		take_from_cd
		;;
	http:*)
		take_from_http
		;;
	~*)
		take_from_cmd
		;;
	^*)
		take_load_run
		;;
	*)
		DIE "Dont know how to get the bootstrap source"
		;;
	esac

    cat > /rootfs/etc/fstab << eof
proc /proc proc defaults 0 0
${firsthd}1 / ext3 defaults,errors=remount-ro 0 1

eof
}

# post install configurations

script_get_from_http() {
	LOG "Downloading first-config script"
	mkdir /rootfs/etc/server-scripts
	wget -O /rootfs/etc/server-scripts/first-config $INITSCR
	chmod +x /rootfs/etc/server-scripts/first-config
	ln -s ../server-scripts/first-config /rootfs/etc/rc2.d/S99zconfig
}

#FIXME!
script_get_from_cd() {
    cp -r /mnt/$INITSCR /rootfs/etc/
    chmod +x /rootfs/etc/$INITSCR/first-config
    ln -s ../$INITSCR/first-config /rootfs/etc/rc2.d/S99zconfig
}

config_postinstall_script() {
	case $INITSCR in
	http:*)
		script_get_from_http
		;;
	*)
		script_get_from_cd
		;;
	esac
}

#FIXME: manual network configuration. ugly is: udev!

config_network() {

	case $IP in

	dhcp)
    cat > /rootfs/etc/network/interfaces << eof
auto lo
iface lo inet loopback

eof

    for inf in /sys/class/net/eth*; do
        cat >> /rootfs/etc/network/interfaces << eof
allow-hotplug $(basename $inf)
iface $(basename $inf) inet dhcp

eof
    done

;;

	manual)
	WARN "Edit /etc/network/interface after booting to new operating system!"
	;;

	esac

    # save main interface address as well
    cat /sys/class/net/eth0/address > /rootfs/etc/main-eth

}

install_bootloader() {
	LOG "Installing boot loader...."
	KER=$(ls /rootfs/boot/vmlinuz*|awk '{print $1}'|sed 's/\/rootfs//g')
	IRD=$(ls /rootfs/boot/initrd*|awk '{print $1}'|sed 's/\/rootfs//g')
	grub-install --root-directory=/rootfs $firsthd
	cat > /rootfs/boot/grub/menu.lst << eof
default 0
timeout 1
title Cluster Node
root (hd0,0)
kernel $KER root=${firsthd}1 ro
initrd $IRD
boot
eof

}

prepare_setting
prepare_parti
make_bootstrap
config_postinstall_script
install_bootloader
config_network

###### FINAL STEP #####
sync
umount /rootfs

PS1='TEST$ ' /bin/sh -i </dev/console >/dev/console 2>&1

PAUSE ">>>> Installing base system finished <<<<"
reboot
