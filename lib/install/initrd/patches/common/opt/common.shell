#!/bin/sh

#[[ -z $quietopt ]] && ;
[[ -z $loglevel ]] && loglevel=0

#######
# Colors
###
_colors_tput() {
   Black="$(tput setaf 0)"
   #BlackBG="$(tput setab 0)"
   DarkGrey="$(tput bold ; tput setaf 0)"
   LightGrey="$(tput setaf 7)"
   #LightGreyBG="$(tput setab 7)"
   White="$(tput bold ; tput setaf 7)"
   Red="$(tput setaf 1)"
   #RedBG="$(tput setab 1)"
   LightRed="$(tput bold ; tput setaf 1)"
   Green="$(tput setaf 2)"
   #GreenBG="$(tput setab 2)"
   LightGreen="$(tput bold ; tput setaf 2)"
   Brown="$(tput setaf 3)"
   #BrownBG="$(tput setab 3)"
   Yellow="$(tput bold ; tput setaf 3)"
   Blue="$(tput setaf 4)"
   #BlueBG="$(tput setab 4)"
   LightBlue="$(tput bold ; tput setaf 4)"
   Purple="$(tput setaf 5)"
   #PurpleBG="$(tput setab 5)"
   Pink="$(tput bold ; tput setaf 5)"
   Cyan="$(tput setaf 6)"
   #CyanBG="$(tput setab 6)"
   LightCyan="$(tput bold ; tput setaf 6)"
   NC="$(tput sgr0)" # No Color

   # Compatibility to old scripts
   black=$Black
   dark_gray=$DarkGrey
   blue=$Blue
   light_blue=$LightBlue
   green=$Green
   light_green=$LightGreen
   cyan=$Cyan
   light_cyan=$LightCyan
   red=$Red
   light_red=$LightRed
   purple=$Purple
   light_purple=$LightPurple
   brown=$Brown
   yellow=$Yellow
   light_gray=$LightGrey
   white=$White
   none=$NC
}

_colors_bash() {
   black="\033[0;30m"
   dark_gray="\033[1;30m"
   blue="\033[0;34m"
   light_blue="\033[1;34m"
   green="\033[0;32m"
   light_green="\033[1;32m"
   cyan="\033[0;36m"
   light_cyan="\033[1;36m"
   red="\033[0;31m"
   light_red="\033[1;31m"
   purple="\033[0;35m"
   light_purple="\033[1;35m"
   brown="\033[0;33m"
   yellow="\033[1;33m"
   light_gray="\033[0;37m"
   white="\033[1;37m"
   none="\033[0m"
}


# Terminal Properties
_get_terminal_properties() {
   STTY=$(stty size 2>/dev/null)
   COLS=$(echo $STTY | awk '{print$2}')
   ROWS=$(echo $STTY | awk '{print$1}')
}

# Print error and die
DIE () { WARN "$@" ; exit 1 ; }

# Print warning
WARN () { echo "${red}* Error${none}: $@" >&2 ; }

# Pause for key press
PAUSE () { echo -ne "${green}Pause:${none}$@"; read; }


# Low level print
qprint() { 
   if [[ -z $quietopt ]]; then
      echo "$@" >&2 ; 
   else
   fi   
}

# log output with a indentation level
#     loglevel: depth of indentation
#     logfile:  where to dump
LOG () {
   [[ -z $logfile ]] && logfile="/dev/null"

   lstr=""
   for i in $(seq 1 $loglevel); do lstr="  "$lstr; done
   lstr="$lstr${brown}$@$none"

   DATE=`date +"%Y.%m.%d-%H:%M.%S"`
   qprint "$lstr"
   echo "$DATE   $@">>$logfile
}

# In/Decrease loglevel
LOG+() { loglevel=$(($loglevel+1)) ; }
LOG-() { loglevel=$(($loglevel-1)) ; }


# Print a message
# mesg  message
mesg() { qprint " ${green}*${none}: $*" >&2 ; }

# Check if package is installed
# _install_pkg  package1 ...
is_installed () {
   while [[ -n $1 ]]; do
      [[ -z $( type -p $1  ) ]] && WARN "missing: $1"
      shift 
   done
}

# Temporary file
TMP=/tmp/tmp.`basename $0`.`cat /dev/urandom | tr -cd a-z | head -c 5`

# Print error code of command
# _eend  errorcode command
_eend() {
   err=$1
   shift
   cmd=$@
   cmd_len=${#cmd}
   cmd="${brown}Running: ${none}$@"
   if [[ $err == 0 ]]; then
      str="${green}ok${none}"
   else
      str="${red}$err${none}"
   fi
   printf "%0s%b %$((COLS - cmd_len ))s%b\n" '' "$cmd" "[$str]" >&2
}

# Execute command in pretty print environemnt with logging
# _  command...
_ () {
#   qprint "${brown}Running:${none} $@" >&2
   if [ $quietopt ]; then
      $@ 2>$TMP.stderr 1>$TMP.stdout
   else
      $@
   fi
   _eend $? $@
}   

# Install a package (debign)
# _install_pkg  package
_install_pkg() { 
   LOG "   Installing package: $1"
   _ apt-get -y --force-yes install $1
   _ apt-get -y --force-yes build-dep $1
}

# Check if files exists
# _exists   file1 file2 ...
_exists() {
   for f in $@; do
      [[ -e $f ]] || DIE "Missing dependency: $f"
   done
}

